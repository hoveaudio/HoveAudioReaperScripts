-- Track Alternatives Manager for Reaper
-- Swaps items on track instead of creating visible child tracks
-- Author: Created for Reaper DAW
-- Version: 4.1 - Now Dockable!

-- Configuration
local MAX_ALTERNATIVES = 26
local ALTERNATIVE_DATA_KEY = "track_alternatives_data"

-- GUI State
local window_open = true
local selected_tracks = {}
local alternatives = {}
local current_alt = nil
local status_msg = ""
local status_time = 0
local mouse_cap_last = 0

-- Initialize graphics window (dockable - remembers last state)
function init()
    gfx.init("Track Alternatives Manager", 500, 500, 1, 100, 100)
    gfx.setfont(1, "Arial", 16)
    gfx.setfont(2, "Arial", 14)
    gfx.setfont(3, "Arial", 12)
end

-- Serialize item data including MIDI
function SerializeItem(item)
    local data = {
        position = reaper.GetMediaItemInfo_Value(item, "D_POSITION"),
        length = reaper.GetMediaItemInfo_Value(item, "D_LENGTH"),
        mute = reaper.GetMediaItemInfo_Value(item, "B_MUTE"),
        fadein = reaper.GetMediaItemInfo_Value(item, "D_FADEINLEN"),
        fadeout = reaper.GetMediaItemInfo_Value(item, "D_FADEOUTLEN"),
        volume = reaper.GetMediaItemInfo_Value(item, "D_VOL"),
        snap_offset = reaper.GetMediaItemInfo_Value(item, "D_SNAPOFFSET"),
        
        takes = {}
    }
    
    local numTakes = reaper.CountTakes(item)
    for i = 0, numTakes - 1 do
        local take = reaper.GetTake(item, i)
        if take then
            local takeData = {
                name = reaper.GetTakeName(take),
                source = nil,
                start_offset = reaper.GetMediaItemTakeInfo_Value(take, "D_STARTOFFS"),
                volume = reaper.GetMediaItemTakeInfo_Value(take, "D_VOL"),
                pan = reaper.GetMediaItemTakeInfo_Value(take, "D_PAN"),
                pitch = reaper.GetMediaItemTakeInfo_Value(take, "D_PITCH"),
                playrate = reaper.GetMediaItemTakeInfo_Value(take, "D_PLAYRATE"),
            }
            
            local source = reaper.GetMediaItemTake_Source(take)
            if source then
                local sourceFile = reaper.GetMediaSourceFileName(source, "")
                local sourceType = reaper.GetMediaSourceType(source, "")
                takeData.source_file = sourceFile
                takeData.source_type = sourceType
                
                -- Check if this is a MIDI take
                if reaper.TakeIsMIDI(take) then
                    takeData.is_midi = true
                    -- Store MIDI data as chunk
                    local _, chunk = reaper.GetItemStateChunk(item, "", false)
                    takeData.midi_chunk = chunk
                end
            end
            
            table.insert(data.takes, takeData)
        end
    end
    
    return data
end

-- Save all items from track to alternative slot
function SaveItemsToAlternative(track, letter)
    if not track then return end
    
    local items_data = {}
    local numItems = reaper.CountTrackMediaItems(track)
    
    for i = 0, numItems - 1 do
        local item = reaper.GetTrackMediaItem(track, i)
        table.insert(items_data, SerializeItem(item))
    end
    
    -- Store in track extended data
    local key = ALTERNATIVE_DATA_KEY .. "_" .. letter
    
    -- Use chunk to store complex data
    local chunk = ""
    for i, item_data in ipairs(items_data) do
        chunk = chunk .. "ITEM_" .. i .. "\n"
        chunk = chunk .. "POS " .. item_data.position .. "\n"
        chunk = chunk .. "LEN " .. item_data.length .. "\n"
        chunk = chunk .. "MUTE " .. item_data.mute .. "\n"
        chunk = chunk .. "VOL " .. item_data.volume .. "\n"
        chunk = chunk .. "FADEIN " .. item_data.fadein .. "\n"
        chunk = chunk .. "FADEOUT " .. item_data.fadeout .. "\n"
        chunk = chunk .. "SNAPOFF " .. item_data.snap_offset .. "\n"
        
        for j, take_data in ipairs(item_data.takes) do
            chunk = chunk .. "TAKE_" .. j .. "\n"
            chunk = chunk .. "NAME " .. (take_data.name or "") .. "\n"
            chunk = chunk .. "FILE " .. (take_data.source_file or "") .. "\n"
            chunk = chunk .. "TYPE " .. (take_data.source_type or "") .. "\n"
            chunk = chunk .. "SOFFS " .. take_data.start_offset .. "\n"
            chunk = chunk .. "VOL " .. take_data.volume .. "\n"
            chunk = chunk .. "PAN " .. take_data.pan .. "\n"
            chunk = chunk .. "PITCH " .. take_data.pitch .. "\n"
            chunk = chunk .. "RATE " .. take_data.playrate .. "\n"
            
            -- Store MIDI data if present
            if take_data.is_midi and take_data.midi_chunk then
                chunk = chunk .. "ISMIDI 1\n"
                -- Encode MIDI chunk with special markers
                chunk = chunk .. "MIDICHUNK_START\n"
                chunk = chunk .. take_data.midi_chunk .. "\n"
                chunk = chunk .. "MIDICHUNK_END\n"
            end
            
            chunk = chunk .. "TAKE_END\n"
        end
        
        chunk = chunk .. "ITEM_END\n"
    end
    
    reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. key, chunk, true)
    
    return #items_data
end

-- Load items from alternative slot to track
function LoadItemsFromAlternative(track, letter)
    if not track then return false end
    
    local key = ALTERNATIVE_DATA_KEY .. "_" .. letter
    local retval, chunk = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. key, "", false)
    
    -- First, always clear existing items
    while reaper.CountTrackMediaItems(track) > 0 do
        local item = reaper.GetTrackMediaItem(track, 0)
        reaper.DeleteTrackMediaItem(track, item)
    end
    
    -- If no data for this alternative, leave track empty
    if not retval or chunk == "" then
        return true
    end
    
    -- Parse chunk and recreate items
    local lines = {}
    for line in chunk:gmatch("[^\n]+") do
        table.insert(lines, line)
    end
    
    local i = 1
    while i <= #lines do
        if lines[i]:match("^ITEM_") then
            local item_data = {}
            i = i + 1
            
            -- Parse item properties
            while i <= #lines and not lines[i]:match("^ITEM_END") and not lines[i]:match("^TAKE_") do
                local key, value = lines[i]:match("(%S+)%s+(.+)")
                if key and value then
                    item_data[key] = tonumber(value) or value
                end
                i = i + 1
            end
            
            local newItem = nil
            local midi_item_chunk = nil
            
            -- Check if this is a MIDI item by looking ahead
            local temp_i = i
            local has_midi = false
            while temp_i <= #lines and not lines[temp_i]:match("^ITEM_END") do
                if lines[temp_i]:match("^ISMIDI") then
                    has_midi = true
                    break
                end
                temp_i = temp_i + 1
            end
            
            -- Parse takes
            while i <= #lines and lines[i]:match("^TAKE_") do
                i = i + 1
                local take_data = {}
                
                while i <= #lines and not lines[i]:match("^TAKE_END") do
                    if lines[i]:match("^MIDICHUNK_START") then
                        i = i + 1
                        midi_item_chunk = ""
                        while i <= #lines and not lines[i]:match("^MIDICHUNK_END") do
                            midi_item_chunk = midi_item_chunk .. lines[i] .. "\n"
                            i = i + 1
                        end
                    else
                        local key, value = lines[i]:match("(%S+)%s+(.+)")
                        if key and value then
                            take_data[key] = value
                        end
                    end
                    i = i + 1
                end
                
                -- If we have MIDI chunk, restore from chunk
                if midi_item_chunk and midi_item_chunk ~= "" then
                    -- Create item from chunk
                    newItem = reaper.AddMediaItemToTrack(track)
                    reaper.SetItemStateChunk(newItem, midi_item_chunk, false)
                    
                    -- Update position and length from our stored data
                    reaper.SetMediaItemInfo_Value(newItem, "D_POSITION", item_data.POS or 0)
                    reaper.SetMediaItemInfo_Value(newItem, "D_LENGTH", item_data.LEN or 1)
                    
                -- Otherwise create audio item
                elseif take_data.FILE and take_data.FILE ~= "" then
                    if not newItem then
                        newItem = reaper.AddMediaItemToTrack(track)
                        reaper.SetMediaItemInfo_Value(newItem, "D_POSITION", item_data.POS or 0)
                        reaper.SetMediaItemInfo_Value(newItem, "D_LENGTH", item_data.LEN or 1)
                        reaper.SetMediaItemInfo_Value(newItem, "B_MUTE", item_data.MUTE or 0)
                        reaper.SetMediaItemInfo_Value(newItem, "D_VOL", item_data.VOL or 1)
                        reaper.SetMediaItemInfo_Value(newItem, "D_FADEINLEN", item_data.FADEIN or 0)
                        reaper.SetMediaItemInfo_Value(newItem, "D_FADEOUTLEN", item_data.FADEOUT or 0)
                        reaper.SetMediaItemInfo_Value(newItem, "D_SNAPOFFSET", item_data.SNAPOFF or 0)
                    end
                    
                    local pcm_source = reaper.PCM_Source_CreateFromFile(take_data.FILE)
                    if pcm_source then
                        local take = reaper.AddTakeToMediaItem(newItem)
                        reaper.SetMediaItemTake_Source(take, pcm_source)
                        reaper.GetSetMediaItemTakeInfo_String(take, "P_NAME", take_data.NAME or "", true)
                        
                        reaper.SetMediaItemTakeInfo_Value(take, "D_STARTOFFS", tonumber(take_data.SOFFS) or 0)
                        reaper.SetMediaItemTakeInfo_Value(take, "D_VOL", tonumber(take_data.VOL) or 1)
                        reaper.SetMediaItemTakeInfo_Value(take, "D_PAN", tonumber(take_data.PAN) or 0)
                        reaper.SetMediaItemTakeInfo_Value(take, "D_PITCH", tonumber(take_data.PITCH) or 0)
                        reaper.SetMediaItemTakeInfo_Value(take, "D_PLAYRATE", tonumber(take_data.RATE) or 1)
                    end
                end
                
                i = i + 1
            end
            
            if newItem then
                reaper.UpdateItemInProject(newItem)
            end
        end
        i = i + 1
    end
    
    return true
end

-- Get track info
function UpdateTrackInfo()
    selected_tracks = {}
    local numSelectedTracks = reaper.CountSelectedTracks(0)
    
    for i = 0, numSelectedTracks - 1 do
        local track = reaper.GetSelectedTrack(0, i)
        table.insert(selected_tracks, track)
    end
    
    if #selected_tracks == 0 then
        alternatives = {}
        current_alt = nil
        return
    end
    
    -- Use first selected track to display alternatives
    local track = selected_tracks[1]
    
    -- Get alternative metadata
    local retval, data = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", "", false)
    
    if not retval or data == "" then
        alternatives = {}
        current_alt = nil
    else
        local currentLetter, count = data:match("([A-Z]):(%d+)")
        current_alt = currentLetter
        
        alternatives = {}
        for i = 0, tonumber(count) - 1 do
            local letter = string.char(65 + i)
            
            -- Count items in this alternative across all selected tracks
            local total_item_count = 0
            for _, sel_track in ipairs(selected_tracks) do
                local key = ALTERNATIVE_DATA_KEY .. "_" .. letter
                local rv, chunk = reaper.GetSetMediaTrackInfo_String(sel_track, "P_EXT:" .. key, "", false)
                
                if rv and chunk ~= "" then
                    for line in chunk:gmatch("[^\n]+") do
                        if line:match("^ITEM_%d+$") then
                            total_item_count = total_item_count + 1
                        end
                    end
                end
            end
            
            -- Get custom name from first track
            local name_key = "track_alt_name_" .. letter
            local rv2, custom_name = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. name_key, "", false)
            
            local altInfo = {
                letter = letter,
                active = (letter == currentLetter),
                name = (rv2 and custom_name ~= "") and custom_name or "",
                item_count = total_item_count
            }
            
            table.insert(alternatives, altInfo)
        end
    end
end

-- Switch to alternative
function SwitchToAlternative(letter)
    if #selected_tracks == 0 then return end
    
    reaper.Undo_BeginBlock()
    reaper.PreventUIRefresh(1)
    
    -- Process each selected track
    for _, track in ipairs(selected_tracks) do
        -- Get current alternative for this track
        local retval, data = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", "", false)
        local currentLetter, count
        
        if retval and data ~= "" then
            currentLetter, count = data:match("([A-Z]):(%d+)")
            
            -- Save current items to current alternative
            if currentLetter then
                SaveItemsToAlternative(track, currentLetter)
            end
            
            -- Load items from target alternative
            LoadItemsFromAlternative(track, letter)
            
            -- Update metadata
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", letter .. ":" .. count, true)
        end
    end
    
    reaper.PreventUIRefresh(-1)
    reaper.UpdateArrange()
    reaper.Undo_EndBlock("Switch Track Alternatives", -1)
    
    status_msg = "Switched " .. #selected_tracks .. " track(s) to Alternative " .. letter
    status_time = reaper.time_precise()
    UpdateTrackInfo()
end

-- Create new alternative
function CreateNewAlternative()
    if #selected_tracks == 0 then return end
    
    reaper.Undo_BeginBlock()
    reaper.PreventUIRefresh(1)
    
    local newLetter = nil
    
    -- Process each selected track
    for _, track in ipairs(selected_tracks) do
        local retval, data = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", "", false)
        
        local count
        if not retval or data == "" then
            -- First time - save current items as A, create empty B
            SaveItemsToAlternative(track, "A")
            
            -- Clear track for B
            while reaper.CountTrackMediaItems(track) > 0 do
                local item = reaper.GetTrackMediaItem(track, 0)
                reaper.DeleteTrackMediaItem(track, item)
            end
            
            -- Set metadata to B with count of 2
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", "B:2", true)
            newLetter = "B"
        else
            local currentLetter, c = data:match("([A-Z]):(%d+)")
            count = tonumber(c)
            
            if count >= MAX_ALTERNATIVES then
                status_msg = "Maximum alternatives reached"
                status_time = reaper.time_precise()
                reaper.PreventUIRefresh(-1)
                return
            end
            
            -- Save current items first
            SaveItemsToAlternative(track, currentLetter)
            
            -- Create new empty alternative
            newLetter = string.char(65 + count)
            count = count + 1
            
            -- Clear track items for new alternative
            while reaper.CountTrackMediaItems(track) > 0 do
                local item = reaper.GetTrackMediaItem(track, 0)
                reaper.DeleteTrackMediaItem(track, item)
            end
            
            -- Update metadata to new alternative
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", newLetter .. ":" .. count, true)
        end
    end
    
    reaper.PreventUIRefresh(-1)
    reaper.UpdateArrange()
    reaper.Undo_EndBlock("Create Track Alternatives", -1)
    
    status_msg = "Created Alternative " .. newLetter .. " on " .. #selected_tracks .. " track(s)"
    status_time = reaper.time_precise()
    UpdateTrackInfo()
end

-- Delete alternative
function DeleteAlternative(letter)
    if #selected_tracks == 0 then return end
    
    reaper.Undo_BeginBlock()
    
    -- Process each selected track
    for _, track in ipairs(selected_tracks) do
        local retval, data = reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", "", false)
        
        if retval and data ~= "" then
            local currentLetter, count = data:match("([A-Z]):(%d+)")
            count = tonumber(count)
            
            if count <= 1 then
                status_msg = "Cannot delete last alternative"
                status_time = reaper.time_precise()
                return
            end
            
            -- Clear the alternative data
            local key = ALTERNATIVE_DATA_KEY .. "_" .. letter
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. key, "", true)
            
            local name_key = "track_alt_name_" .. letter
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. name_key, "", true)
            
            -- If deleting current, switch to A
            if letter == currentLetter then
                LoadItemsFromAlternative(track, "A")
                currentLetter = "A"
            end
            
            count = count - 1
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:track_alt_meta", currentLetter .. ":" .. count, true)
        end
    end
    
    reaper.UpdateArrange()
    reaper.Undo_EndBlock("Delete Track Alternatives", -1)
    
    status_msg = "Deleted Alternative " .. letter .. " from " .. #selected_tracks .. " track(s)"
    status_time = reaper.time_precise()
    UpdateTrackInfo()
end

-- Rename alternative
function RenameAlternative(letter)
    if #selected_tracks == 0 then return end
    
    local name_key = "track_alt_name_" .. letter
    local rv, current_name = reaper.GetSetMediaTrackInfo_String(selected_tracks[1], "P_EXT:" .. name_key, "", false)
    
    local retval, newName = reaper.GetUserInputs("Rename Alternative " .. letter, 1, "Name:", current_name or "")
    if retval then
        reaper.Undo_BeginBlock()
        
        -- Apply to all selected tracks
        for _, track in ipairs(selected_tracks) do
            reaper.GetSetMediaTrackInfo_String(track, "P_EXT:" .. name_key, newName, true)
        end
        
        reaper.Undo_EndBlock("Rename Track Alternatives", -1)
        
        status_msg = "Renamed Alternative " .. letter .. " on " .. #selected_tracks .. " track(s)"
        status_time = reaper.time_precise()
        UpdateTrackInfo()
    end
end

-- Check if mouse is over rectangle
function MouseOver(x, y, w, h)
    return gfx.mouse_x >= x and gfx.mouse_x <= x + w and gfx.mouse_y >= y and gfx.mouse_y <= y + h
end

-- Draw button
function DrawButton(x, y, w, h, text, enabled)
    enabled = enabled == nil and true or enabled
    
    local hover = MouseOver(x, y, w, h)
    local clicked = false
    
    if enabled then
        if hover then
            gfx.set(0.3, 0.5, 0.8, 1)
            if gfx.mouse_cap == 1 and mouse_cap_last == 0 then
                clicked = true
            end
        else
            gfx.set(0.2, 0.3, 0.5, 1)
        end
    else
        gfx.set(0.15, 0.15, 0.15, 1)
    end
    
    gfx.rect(x, y, w, h, 1)
    
    gfx.set(1, 1, 1, enabled and 1 or 0.3)
    gfx.setfont(2)
    local tw, th = gfx.measurestr(text)
    gfx.x = x + (w - tw) / 2
    gfx.y = y + (h - th) / 2
    gfx.drawstr(text)
    
    return clicked
end

-- Draw alternative item
function DrawAlternativeItem(x, y, w, h, alt)
    local hover = MouseOver(x, y, w, h)
    
    if alt.active then
        gfx.set(0.2, 0.6, 0.3, 1)
    elseif hover then
        gfx.set(0.25, 0.25, 0.3, 1)
    else
        gfx.set(0.15, 0.15, 0.2, 1)
    end
    
    gfx.rect(x, y, w, h, 1)
    
    gfx.set(0.4, 0.4, 0.4, 1)
    gfx.rect(x, y, w, h, 0)
    
    gfx.set(1, 1, 1, 1)
    gfx.setfont(2)
    
    local label = "Alternative " .. alt.letter
    if alt.name ~= "" then
        label = label .. " - " .. alt.name
    end
    label = label .. " (" .. alt.item_count .. " items)"
    
    gfx.x = x + 10
    gfx.y = y + 8
    gfx.drawstr(label)
    
    local btn_w = 60
    local btn_h = 24
    local btn_spacing = 5
    local btn_y = y + (h - btn_h) / 2
    
    local switch_clicked = DrawButton(x + w - (btn_w * 4 + btn_spacing * 3 + 10), btn_y, btn_w, btn_h, "Switch", not alt.active)
    local switch_close_clicked = DrawButton(x + w - (btn_w * 3 + btn_spacing * 2 + 10), btn_y, btn_w, btn_h, "Sw+Close", not alt.active)
    local rename_clicked = DrawButton(x + w - (btn_w * 2 + btn_spacing + 10), btn_y, btn_w, btn_h, "Rename", true)
    local delete_clicked = DrawButton(x + w - (btn_w + 10), btn_y, btn_w, btn_h, "Delete", #alternatives > 1)
    
    if switch_clicked and not alt.active then
        SwitchToAlternative(alt.letter)
    end
    
    if switch_close_clicked and not alt.active then
        SwitchToAlternative(alt.letter)
        gfx.quit()
    end
    
    if rename_clicked then
        RenameAlternative(alt.letter)
    end
    
    if delete_clicked and #alternatives > 1 then
        DeleteAlternative(alt.letter)
    end
end

-- Main draw function
function Draw()
    gfx.set(0.1, 0.1, 0.12, 1)
    gfx.rect(0, 0, gfx.w, gfx.h, 1)
    
    local y = 10
    
    gfx.set(1, 1, 1, 1)
    gfx.setfont(1)
    gfx.x = 10
    gfx.y = y
    gfx.drawstr("Track Alternatives Manager")
    y = y + 30
    
    if #selected_tracks == 0 then
        gfx.set(0.8, 0.8, 0.8, 1)
        gfx.setfont(2)
        gfx.x = 10
        gfx.y = y + 20
        gfx.drawstr("Please select one or more tracks to manage alternatives")
    else
        gfx.set(0.8, 0.8, 0.8, 1)
        gfx.setfont(3)
        gfx.x = 10
        gfx.y = y
        
        local track_label = ""
        if #selected_tracks == 1 then
            local retval, trackName = reaper.GetSetMediaTrackInfo_String(selected_tracks[1], "P_NAME", "", false)
            track_label = "Selected Track: " .. (trackName ~= "" and trackName or "Untitled")
        else
            track_label = "Selected Tracks: " .. #selected_tracks .. " tracks"
        end
        
        gfx.drawstr(track_label)
        y = y + 25
        
        if #alternatives == 0 then
            gfx.x = 10
            gfx.y = y + 10
            gfx.drawstr("No alternatives yet. Click 'New Alternative' to create one.")
            y = y + 40
        else
            gfx.x = 10
            gfx.y = y
            gfx.drawstr("Alternatives: " .. #alternatives .. " (Items swap on the same track)")
            y = y + 30
            
            local item_h = 40
            local item_spacing = 5
            
            for i, alt in ipairs(alternatives) do
                DrawAlternativeItem(10, y, gfx.w - 20, item_h, alt)
                y = y + item_h + item_spacing
            end
        end
        
        y = y + 20
        
        local new_clicked = DrawButton(10, y, 150, 35, "New Alternative", #alternatives < MAX_ALTERNATIVES)
        if new_clicked then
            CreateNewAlternative()
        end
    end
    
    if status_msg ~= "" and reaper.time_precise() - status_time < 3 then
        gfx.set(0.3, 0.8, 0.3, 1)
        gfx.setfont(3)
        gfx.x = 10
        gfx.y = gfx.h - 25
        gfx.drawstr(status_msg)
    end
    
    mouse_cap_last = gfx.mouse_cap
end

-- Main loop
function Main()
    local char = gfx.getchar()
    
    -- Close on ESC key (27) or window close
    if char < 0 or char == 27 then
        return
    end
    
    UpdateTrackInfo()
    Draw()
    gfx.update()
    
    reaper.defer(Main)
end

-- Start
init()
UpdateTrackInfo()
Main()
